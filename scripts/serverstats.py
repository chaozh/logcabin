#!/usr/bin/env python
# Copyright (c) 2015 Diego Ongaro
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Outputs diagnostic information from LogCabin servers in a human-readable way.

Usage:
  serverstats.py [options] <server>...
  serverstats.py [options] --input=<file>...
  serverstats.py (-h | --help)

Options:
  -h --help               Show this help message and exit
  --input=<file>          Instead of connecting to server(s) for stats, format
                          the previously gathered text-format stats found in
                          file(s). Pass - for stdin.
  --raw                   Output raw ServerStats.proto information
  -t,--timeout=<seconds>  Number of seconds to wait for client to complete
                          before exiting with an error [default: 10]

LogCabin's ServerStats binary (C++) must be accessible in either LOGCABIN_PATH
or PATH.

ServerStats_pb2.py (the Python module generated by protoc from
ServerStats.proto) must be accessible in either PYTHONPATH, LOGCABIN_PATH, or
LOGCABIN_PYTHONPATH.
"""

from __future__ import division, print_function

import sys
import os

try:
    sys.path.extend(os.environ['LOGCABIN_PATH'].split(':'))
except KeyError:
    pass
try:
    sys.path.extend(os.environ['LOGCABIN_PYTHONPATH'].split(':'))
except KeyError:
    pass

from docopt import docopt
from termcolor import colored
import errno
import google.protobuf
import subprocess
import time

from ServerStats_pb2 import ServerStats

def check_output_compat(*popenargs, **kwargs):
    # This function was copied from Python 2.7's subprocess module.
    # This function only is:
    # Copyright (c) 2003-2005 by Peter Astrand <astrand@lysator.liu.se>
    # Licensed to PSF under a Contributor Agreement.
    # See http://www.python.org/2.4/license for licensing details.
    if 'stdout' in kwargs:
        raise ValueError('stdout argument not allowed, it will be overridden.')
    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise subprocess.CalledProcessError(retcode, cmd, output=output)
    return output

# Python 2.6 doesn't have subprocess.check_output
try:
    subprocess.check_output
except AttributeError:
    subprocess.check_output = check_output_compat


# Protobuf 2.4.x support for enums in Python is lacking
def fix_enums(cls):
    import enum_type_wrapper
    descriptor = cls.DESCRIPTOR
    for enum_type in descriptor.enum_types:
        setattr(cls, enum_type.name, enum_type_wrapper.EnumTypeWrapper(enum_type))
        for enum_value in enum_type.values:
          setattr(cls, enum_value.name, enum_value.number)

try:
    FOLLOWER  = ServerStats.Raft.State.Value('FOLLOWER')
except AttributeError:
    fix_enums(ServerStats.Raft)

FOLLOWER  = ServerStats.Raft.State.Value('FOLLOWER')
CANDIDATE = ServerStats.Raft.State.Value('CANDIDATE')
LEADER    = ServerStats.Raft.State.Value('LEADER')

STATECOLOR = {
    FOLLOWER: None,
    CANDIDATE: 'yellow',
    LEADER: 'green',
}

class Print(object):
    def __init__(self):
        self.indentlevel = 0
    def indent(self):
        self.indentlevel += 2
    def unindent(self):
        self.indentlevel -= 2
    def __call__(self, s=''):
        print(' ' * self.indentlevel + s)

nowish = time.time() * 1e9

def abstime(t):
    if t < 0:
        return '-infinity'
    if t > nowish + 365 * 24 * 60 * 60 * 1e9:
        return '+infinity'
    return '{0}.{1:03d}'.format(
        time.strftime('%F %T', time.localtime(t / 1e9)),
        int((t % 1e9) / 1e6))

def reltime(t, base):
    if t < 0:
        return '-infinity'
    if t > nowish + 365 * 24 * 60 * 60 * 1e9:
        return '+infinity'
    return '{0:+0.3f} ms'.format((t - base) / 1e6)

def printraft(print, raft, stats, leaders):
    statecolor = STATECOLOR[raft.state]
    if (raft.state == LEADER and
        max(leaders.keys()) != raft.current_term):
        statecolor = 'red'
    print(colored('{state} at term {0.current_term}'.format(
        raft,
        state=ServerStats.Raft.State.Name(raft.state).title()),
        STATECOLOR[raft.state]))
    if raft.state == FOLLOWER:
        if raft.leader_id > 0:
            try:
                latest_leader_term = max(leaders.keys())
                latest_leader_id = leaders[latest_leader_term]
            except:
                latest_leader_term = 0
                latest_leader_id = 0
            print(colored('Current leader is thought to be server '
                          '{0.leader_id}'.format(raft),
                          'yellow' if latest_leader_id != raft.leader_id
                                   else None))
        else:
            print('Current leader is unknown')
    print('Snapshot covers entries 1 through {0.last_snapshot_index} '
          '({0.last_snapshot_bytes} bytes)'.format(raft))
    print('Log covers entries {0.log_start_index} through {0.last_log_index} '
          '({0.log_bytes} bytes)'.format(raft))
    if raft.commit_index < raft.last_log_index:
        print(colored(
            'Entries 1 through {0.commit_index} committed'.format(raft),
            'yellow'))
    else:
        print('All log entries committed')


    if raft.state == LEADER:
        for peer in raft.peer:
            if peer.server_id != stats.server_id:
                continue
            if peer.last_synced_index == raft.last_log_index:
                print('All log entries flushed to disk')
            else:
                print(colored('Log flushed to disk up through entry {0}'.format(
                    peer.last_synced_index),
                    'yellow'))
    print('Voted for server {0.voted_for}'.format(
        raft))
    if raft.state == CANDIDATE:
        print('Starting next election in {0}'.format(
            reltime(raft.start_election_at, stats.end_at)))
    print('Withholding votes for {0}'.format(
        reltime(raft.withhold_votes_until, stats.end_at)))

    old_servers = []
    new_servers = []
    staging_servers = []
    for peer in raft.peer:
        if peer.old_member:
            old_servers.append(int(peer.server_id))
        if peer.new_member:
            new_servers.append(int(peer.server_id))
        if peer.staging_member:
            staging_servers.append(int(peer.server_id))
    old_servers.sort()
    new_servers.sort()
    staging_servers.sort()
    if new_servers or staging_servers:
        print(colored('Configuration: old/curr={0}, new={1}, staging={2}'.format(
            old_servers, new_servers, staging_servers),
            'yellow'))
    else:
        print(colored('Configuration: {0}'.format(old_servers)))

    for peer in raft.peer:
        if (peer.server_id == stats.server_id or
            raft.state == ServerStats.Raft.State.Value('FOLLOWER')):
            continue
        print('Peer {0.server_id} ({membership}):'.format(
            peer, membership=', '.join(filter(None,
                                   ['old/curr' if peer.old_member else '',
                                    'new' if peer.new_member else '',
                                    'staging' if peer.staging_member else '']
                                  ))))
        print.indent()
        if raft.state == CANDIDATE:
            if peer.request_vote_done:
                if peer.have_vote:
                    print('Vote granted')
                else:
                    print('Vote denied')
            else:
                print('Vote response not yet received')
        if raft.state == LEADER:
            if peer.force_heartbeat:
                print('Forcing heartbeats to discover log divergence')
            behind = peer.next_index < raft.last_log_index + 1
            print(colored('Next index: {0.next_index}'.format(peer),
                         'yellow' if behind else None))
            behind = peer.last_agree_index < raft.last_log_index
            print(colored('Match index: {0.last_agree_index}'.format(peer),
                         'yellow' if behind else None))
            if peer.staging_member:
                if peer.is_caught_up:
                    print('Caught up')
                else:
                    print('Not caught up')
            print('Next heartbeat in {0}'.format(
                reltime(peer.next_heartbeat_at, stats.end_at)))
        if peer.backoff_until >= stats.end_at:
            print('Backoff for {0}'.format(
                reltime(peer.backoff_until, stats.end_at)))
        print.unindent()

def checkleaders(allstats):
    terms = []
    leaders = {}
    for stats in allstats:
        if stats.raft.state == LEADER:
            assert stats.raft.current_term not in leaders
            leaders[stats.raft.current_term] = stats.server_id
        terms.append(stats.raft.current_term)
    if not leaders:
        print(colored('No current leader', 'red'))
        print()
    return leaders

def printstats(allstats):
    print = Print()
    leaders  = checkleaders(allstats)
    for stats in allstats:
        print('Server {0.server_id} at {0.address}:'.format(stats))
        print.indent()
        elapsed = stats.end_at - stats.start_at
        printraft(print, stats.raft, stats, leaders)
        print('Stats collected at {0}'.format(abstime(stats.end_at)))
        print(colored('Took {0:0.3f} ms to generate stats'.format(
            elapsed / 1e6),
              'red' if elapsed > 10e6 else None))
        print.unindent()
        print()

def main():
    arguments = docopt(__doc__)
    # print(arguments)

    allstats = []

    for f in arguments['--input']:
        if f == '-':
            text = sys.stdin.read()
        else:
            text = open(f).read()
        stats = ServerStats()
        google.protobuf.text_format.Merge(text, stats)
        allstats.append(stats)

    env = dict(os.environ)
    try:
        env['PATH'] = env['LOGCABIN_PATH'] + ':' + env['PATH']
    except KeyError:
        pass

    for server in arguments['<server>']:
        try:
            binproto = subprocess.check_output(
                ['ServerStats',
                 '-b',
                 '-t', arguments['--timeout'],
                 server],
                env=env)
        except OSError as e:
            if e.errno == errno.ENOENT:
                raise RuntimeError('Could not find ServerStats binary. '
                                   'Check your LOGCABIN_PATH setting.')
            else:
                raise
        stats = ServerStats()
        stats.ParseFromString(binproto)
        if not stats.ListFields():
            print('failed to get stats for {0}'.format(server))
            print()
        else:
            allstats.append(stats)

    if arguments['--raw']:
        for stats in allstats:
            print(stats)
        print()

    printstats(allstats)

if __name__ == '__main__':
    main()
